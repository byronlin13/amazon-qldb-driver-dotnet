<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Repos\amazon-qldb-driver-dotnet\Amazon.QLDB.Driver\driver\QldbDriverBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

namespace Amazon.QLDB.Driver
{
    using System;
    using System.Collections.Concurrent;
    using System.Threading;
    using System.Threading.Tasks;
    using Amazon.QLDBSession;
    using Amazon.QLDBSession.Model;
    using Microsoft.Extensions.Logging;

    internal class QldbDriverBase&lt;T&gt; : IDisposable
        where T : BaseQldbSession
    {
        internal const string TableNameQuery =
                &quot;SELECT VALUE name FROM information_schema.user_tables WHERE status = &#39;ACTIVE&#39;&quot;;

        internal static readonly RetryPolicy DefaultRetryPolicy = RetryPolicy.Builder().Build();

        internal readonly string LedgerName;
        internal readonly IAmazonQLDBSession SessionClient;
        internal readonly ILogger Logger;
        private readonly SemaphoreSlim poolPermits;
        private readonly BlockingCollection&lt;T&gt; sessionPool;
        private bool isClosed = false;

        internal QldbDriverBase(
            string ledgerName,
            IAmazonQLDBSession sessionClient,
            int maxConcurrentTransactions,
            ILogger logger)
        {
            this.LedgerName = ledgerName;
            this.SessionClient = sessionClient;
            this.Logger = logger;
            this.poolPermits = new SemaphoreSlim(maxConcurrentTransactions, maxConcurrentTransactions);
            this.sessionPool = new BlockingCollection&lt;T&gt;(maxConcurrentTransactions);
        }

        public void Dispose()
        {
            if (!this.isClosed)
            {
                this.isClosed = true;
                while (this.sessionPool.TryTake(out T session))
                {
                    session.End();
                }

                this.sessionPool.Dispose();
                this.SessionClient.Dispose();
                this.poolPermits.Dispose();
            }
        }

        internal void ReleaseSession(T session)
        {
            this.sessionPool.Add(session);
            this.Logger.LogDebug(&quot;Session returned to pool; pool size is now {}.&quot;, this.sessionPool.Count);
            this.poolPermits.Release();
        }

        internal void ThrowIfClosed()
        {
            if (this.isClosed)
            {
                this.Logger.LogError(ExceptionMessages.DriverClosed);
                throw new QldbDriverException(ExceptionMessages.DriverClosed);
            }
        }

        internal T GetSessionFromPool()
        {
            this.Logger.LogDebug(
                &quot;Getting session. There are {} free sessions and {} available permits.&quot;,
                this.sessionPool.Count,
                this.sessionPool.BoundedCapacity - this.poolPermits.CurrentCount);

            if (this.poolPermits.Wait(0))
            {
                return this.sessionPool.TryTake(out T session) ? session : null;
            }
            else
            {
                this.Logger.LogError(ExceptionMessages.MaxConcurrentTransactionsExceeded);
                throw new QldbDriverException(ExceptionMessages.MaxConcurrentTransactionsExceeded);
            }
        }

        internal bool GetShouldReplaceDeadSessionOrThrowIfNoRetry(
            QldbTransactionException qte,
            T currentSession,
            int retryAttempt,
            RetryPolicy retryPolicy,
            Action&lt;int&gt; retryAction)
        {
            bool replaceDeadSession = this.GetIsSessionDeadAndThrowIfNoRetry(
                qte,
                currentSession,
                retryPolicy.MaxRetries,
                retryAttempt);
            try
            {
                retryAction?.Invoke(retryAttempt);
                Thread.Sleep(retryPolicy.BackoffStrategy.CalculateDelay(
                    new RetryPolicyContext(retryAttempt, qte.InnerException)));
            }
            catch (Exception)
            {
                // Safeguard against semaphore leak if parameter actions throw exceptions.
                if (replaceDeadSession)
                {
                    this.poolPermits.Release();
                }

                throw;
            }

            return replaceDeadSession;
        }

        internal async Task&lt;bool&gt; GetShouldReplaceDeadSessionOrThrowIfNoRetryAsync(
            QldbTransactionException qte,
            T currentSession,
            int retryAttempt,
            RetryPolicy retryPolicy,
            CancellationToken token)
        {
            bool replaceDeadSession = this.GetIsSessionDeadAndThrowIfNoRetry(
                qte,
                currentSession,
                retryPolicy.MaxRetries,
                retryAttempt);
            try
            {
                var backoffDelay = retryPolicy.BackoffStrategy.CalculateDelay(
                    new RetryPolicyContext(retryAttempt, qte.InnerException));
                await Task.Delay(backoffDelay, token);
            }
            catch (Exception)
            {
                // Safeguard against semaphore leak if parameter actions throw exceptions.
                if (replaceDeadSession)
                {
                    this.poolPermits.Release();
                }

                throw;
            }

            return replaceDeadSession;
        }

        private bool GetIsSessionDeadAndThrowIfNoRetry(
            QldbTransactionException qte,
            T currentSession,
            int maxRetries,
            int retryAttempt)
        {
            if (qte is RetriableException)
            {
                // Always retry on the first attempt if failure was caused by a stale session in the pool.
                if (qte.InnerException is InvalidSessionException &amp;&amp; retryAttempt == 1)
                {
                    this.Logger.LogDebug(&quot;Initial session received from pool invalid. Retrying...&quot;);
                    return true;
                }

                // Normal retry logic.
                if (retryAttempt &gt; maxRetries)
                {
                    if (qte.IsSessionAlive)
                    {
                        this.ReleaseSession(currentSession);
                    }
                    else
                    {
                        this.poolPermits.Release();
                    }

                    throw qte.InnerException;
                }

                this.Logger.LogInformation(&quot;A recoverable error has occurred. Attempting retry #{}.&quot;, retryAttempt);
                this.Logger.LogDebug(
                    &quot;Errored Transaction ID: {}. Error cause: {}&quot;,
                    qte.TransactionId,
                    qte.InnerException.ToString());
                if (qte.IsSessionAlive)
                {
                    this.Logger.LogDebug(&quot;Retrying with a different session...&quot;);
                    this.ReleaseSession(currentSession);
                }
                else
                {
                    this.Logger.LogDebug(&quot;Replacing invalid session...&quot;);
                }

                return !qte.IsSessionAlive;
            }
            else
            {
                if (qte.IsSessionAlive)
                {
                    this.ReleaseSession(currentSession);
                }
                else
                {
                    this.poolPermits.Release();
                }

                throw qte.InnerException;
            }
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[30,9,30,97,1],[37,9,37,39,1],[39,9,43,28,1],[44,9,44,10,1],[45,13,45,42,1],[46,13,46,48,1],[47,13,47,34,1],[48,13,48,104,1],[49,13,49,85,1],[50,9,50,10,1],[53,9,53,10,1],[54,13,54,32,1],[55,13,55,14,1],[56,17,56,38,1],[57,17,57,64,1],[58,17,58,18,0],[59,21,59,35,0],[60,17,60,18,0],[62,17,62,44,1],[63,17,63,46,1],[64,17,64,44,1],[65,13,65,14,1],[66,9,66,10,1],[69,9,69,10,1],[70,13,70,43,1],[71,13,71,108,1],[72,13,72,40,1],[73,9,73,10,1],[76,9,76,10,1],[77,13,77,31,1],[78,13,78,14,1],[79,17,79,70,1],[80,17,80,79,1],[82,9,82,10,1],[85,9,85,10,1],[86,13,89,83,1],[91,13,91,42,1],[92,13,92,14,1],[93,17,93,81,1],[96,13,96,14,1],[97,17,97,91,1],[98,17,98,100,1],[100,9,100,10,1],[108,9,108,10,1],[109,13,113,31,1],[115,13,115,14,1],[116,17,116,51,1],[117,17,118,80,1],[119,13,119,14,1],[120,13,120,30,0],[121,13,121,14,0],[123,17,123,40,0],[124,17,124,18,0],[125,21,125,48,0],[126,17,126,18,0],[128,17,128,23,0],[131,13,131,39,1],[132,9,132,10,1],[140,9,140,10,1],[141,13,145,31,1],[147,13,147,14,1],[148,17,149,79,1],[150,17,150,55,1],[151,13,151,14,1],[152,13,152,30,0],[153,13,153,14,0],[155,17,155,40,0],[156,17,156,18,0],[157,21,157,48,0],[158,17,158,18,0],[160,17,160,23,0],[163,13,163,39,1],[164,9,164,10,1],[171,9,171,10,1],[172,13,172,43,1],[173,13,173,14,1],[175,17,175,88,1],[176,17,176,18,1],[177,21,177,101,1],[178,21,178,33,1],[182,17,182,47,1],[183,17,183,18,1],[184,21,184,44,1],[185,21,185,22,1],[186,25,186,61,1],[187,21,187,22,1],[189,21,189,22,0],[190,25,190,52,0],[191,21,191,22,0],[193,21,193,46,1],[196,17,196,117,1],[197,17,200,52,1],[201,17,201,40,1],[202,17,202,18,1],[203,21,203,82,1],[204,21,204,57,1],[205,17,205,18,1],[207,17,207,18,1],[208,21,208,74,1],[209,17,209,18,1],[211,17,211,44,1],[214,13,214,14,1],[215,17,215,40,1],[216,17,216,18,1],[217,21,217,57,1],[218,17,218,18,1],[220,17,220,18,0],[221,21,221,48,0],[222,17,222,18,0],[224,17,224,42,1],[226,9,226,10,1]]);
    </script>
  </body>
</html>