<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Repos\amazon-qldb-driver-dotnet\Amazon.QLDB.Driver\driver\QldbDriver.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

namespace Amazon.QLDB.Driver
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Amazon.QLDBSession;
    using Amazon.Runtime;
    using Microsoft.Extensions.Logging;

    /// &lt;summary&gt;
    /// &lt;para&gt;Represents a factory for accessing a specific ledger within QLDB. This class or
    /// &lt;see cref=&quot;AsyncQldbDriver&quot;/&gt; should be the main entry points to any interaction with QLDB.&lt;/para&gt;
    ///
    /// &lt;para&gt;
    /// This factory pools sessions and attempts to return unused but available sessions when getting new sessions.
    /// The pool does not remove stale sessions until a new session is retrieved. The default pool size is the maximum
    /// amount of connections the session client allows set in the &lt;see cref=&quot;ClientConfig&quot;/&gt;. &lt;see cref=&quot;Dispose&quot;/&gt;
    /// should be called when this factory is no longer needed in order to clean up resources, ending all sessions in
    /// the pool.
    /// &lt;/para&gt;
    /// &lt;/summary&gt;
    public class QldbDriver : IQldbDriver
    {
        private readonly QldbDriverBase&lt;QldbSession&gt; driverBase;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;QldbDriver&quot;/&gt; class.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;ledgerName&quot;&gt;The ledger to create sessions to.&lt;/param&gt;
        /// &lt;param name=&quot;sessionClient&quot;&gt;AWS SDK session client for QLDB.&lt;/param&gt;
        /// &lt;param name=&quot;maxConcurrentTransactions&quot;&gt;The maximum number of concurrent transactions.&lt;/param&gt;
        /// &lt;param name=&quot;logger&quot;&gt;The logger to use.&lt;/param&gt;
        internal QldbDriver(
            string ledgerName,
            IAmazonQLDBSession sessionClient,
            int maxConcurrentTransactions,
            ILogger logger)
        {
            this.driverBase =
                new QldbDriverBase&lt;QldbSession&gt;(ledgerName, sessionClient, maxConcurrentTransactions, logger);
        }

        /// &lt;summary&gt;
        /// Retrieve a builder object for creating a &lt;see cref=&quot;QldbDriver&quot;/&gt;.
        /// &lt;/summary&gt;
        ///
        /// &lt;returns&gt;The builder object for creating a &lt;see cref=&quot;QldbDriver&quot;/&gt;.&lt;/returns&gt;.
        public static QldbDriverBuilder Builder()
        {
            return new QldbDriverBuilder();
        }

        /// &lt;summary&gt;
        /// Close this driver and end all sessions in the current pool. No-op if already closed.
        /// &lt;/summary&gt;
        public void Dispose()
        {
            this.driverBase.Dispose();
        }

        /// &lt;summary&gt;
        /// Start a session, then execute the Executor lambda against QLDB within a transaction where no result is
        /// expected, and end the session.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;action&quot;&gt;The Executor lambda with no return value representing the block of code to be executed
        /// within the transaction. This cannot have any side effects as it may be invoked multiple times.&lt;/param&gt;
        ///
        /// &lt;exception cref=&quot;TransactionAbortedException&quot;&gt;
        /// Thrown if the Executor lambda calls &lt;see cref=&quot;TransactionExecutor.Abort&quot;/&gt;.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;QldbDriverException&quot;&gt;
        /// Thrown when called on a disposed instance.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;AmazonServiceException&quot;&gt;
        /// Thrown when there is an error executing against QLDB.
        /// &lt;/exception&gt;
        public void Execute(Action&lt;TransactionExecutor&gt; action)
        {
            this.Execute(action, QldbDriverBase&lt;QldbSession&gt;.DefaultRetryPolicy);
        }

        /// &lt;summary&gt;
        /// Start a session, then execute the Executor lambda against QLDB within a transaction where no result is
        /// expected, and end the session.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;action&quot;&gt;The Executor lambda with no return value representing the block of code to be executed
        /// within the transaction. This cannot have any side effects as it may be invoked multiple times.&lt;/param&gt;
        /// &lt;param name=&quot;retryAction&quot;&gt;A lambda that is invoked when the Executor lambda is about to be retried due to
        /// a retriable error. Can be null if not applicable.&lt;/param&gt;
        ///
        /// &lt;exception cref=&quot;TransactionAbortedException&quot;&gt;
        /// Thrown if the Executor lambda calls &lt;see cref=&quot;TransactionExecutor.Abort&quot;/&gt;.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;QldbDriverException&quot;&gt;
        /// Thrown when called on a disposed instance.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;AmazonServiceException&quot;&gt;
        /// Thrown when there is an error executing against QLDB.
        /// &lt;/exception&gt;
        [Obsolete(&quot;As of release 1.0, replaced by &#39;retryPolicy&#39;. Will be removed in the next major release.&quot;)]
        public void Execute(Action&lt;TransactionExecutor&gt; action, Action&lt;int&gt; retryAction)
        {
            this.Execute(
                txn =&gt;
                {
                    action.Invoke(txn);
                    return false;
                },
                retryAction);
        }

        /// &lt;summary&gt;
        /// Start a session, then execute the Executor lambda against QLDB within a transaction where no result is
        /// expected, and end the session.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;action&quot;&gt;The Executor lambda with no return value representing the block of code to be executed
        /// within the transaction. This cannot have any side effects as it may be invoked multiple times.&lt;/param&gt;
        /// &lt;param name=&quot;retryPolicy&quot;&gt;A &lt;see cref=&quot;RetryPolicy&quot;/&gt; that overrides the RetryPolicy set when creating the
        /// driver. The given retry policy will be used when retrying the transaction.&lt;/param&gt;
        ///
        /// &lt;exception cref=&quot;TransactionAbortedException&quot;&gt;
        /// Thrown if the Executor lambda calls &lt;see cref=&quot;TransactionExecutor.Abort&quot;/&gt;.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;QldbDriverException&quot;&gt;
        /// Thrown when called on a disposed instance.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;AmazonServiceException&quot;&gt;
        /// Thrown when there is an error executing against QLDB.
        /// &lt;/exception&gt;
        public void Execute(Action&lt;TransactionExecutor&gt; action, RetryPolicy retryPolicy)
        {
            this.Execute(
                txn =&gt;
                {
                    action.Invoke(txn);
                    return false;
                },
                retryPolicy);
        }

        /// &lt;summary&gt;
        /// Start a session, then execute the Executor lambda against QLDB and retrieve the result within a transaction,
        /// and end the session.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;func&quot;&gt;The Executor lambda representing the block of code to be executed within the transaction.
        /// This cannot have any side effects as it may be invoked multiple times, and the result cannot be trusted
        /// until the transaction is committed.&lt;/param&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The return type.&lt;/typeparam&gt;
        ///
        /// &lt;returns&gt;The return value of executing the executor. Note that if you directly return a
        /// &lt;see cref=&quot;IResult&quot;/&gt;, this will be automatically buffered in memory before the implicit commit to allow
        /// reading, as the commit will close any open results. Any other &lt;see cref=&quot;IResult&quot;/&gt; instances created within
        /// the executor block will be invalidated, including if the return value is an object which nests said
        /// &lt;see cref=&quot;IResult&quot;/&gt; instances within it.&lt;/returns&gt;
        ///
        /// &lt;exception cref=&quot;TransactionAbortedException&quot;&gt;
        /// Thrown if the Executor lambda calls &lt;see cref=&quot;TransactionExecutor.Abort&quot;/&gt;.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;QldbDriverException&quot;&gt;
        /// Thrown when called on a disposed instance.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;AmazonServiceException&quot;&gt;
        /// Thrown when there is an error executing against QLDB.
        /// &lt;/exception&gt;
        public T Execute&lt;T&gt;(Func&lt;TransactionExecutor, T&gt; func)
        {
            return this.Execute(func, QldbDriverBase&lt;QldbSession&gt;.DefaultRetryPolicy);
        }

        /// &lt;summary&gt;
        /// Start a session, then execute the Executor lambda against QLDB and retrieve the result within a transaction,
        /// and end the session.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;func&quot;&gt;The Executor lambda representing the block of code to be executed within the transaction.
        /// This cannot have any side effects as it may be invoked multiple times, and the result cannot be trusted
        /// until the transaction is committed.&lt;/param&gt;
        /// &lt;param name=&quot;retryAction&quot;&gt;A lambda that is invoked when the Executor lambda is about to be retried due to
        /// a retriable error. Can be null if not applicable.&lt;/param&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The return type.&lt;/typeparam&gt;
        ///
        /// &lt;returns&gt;The return value of executing the executor. Note that if you directly return a
        /// &lt;see cref=&quot;IResult&quot;/&gt;, this will be automatically buffered in memory before the implicit commit to allow
        /// reading, as the commit will close any open results. Any other &lt;see cref=&quot;IResult&quot;/&gt; instances created within
        /// the executor block will be invalidated, including if the return value is an object which nests said
        /// &lt;see cref=&quot;IResult&quot;/&gt; instances within it.
        /// &lt;/returns&gt;
        ///
        /// &lt;exception cref=&quot;TransactionAbortedException&quot;&gt;
        /// Thrown if the Executor lambda calls &lt;see cref=&quot;TransactionExecutor.Abort&quot;/&gt;.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;QldbDriverException&quot;&gt;
        /// Thrown when called on a disposed instance.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;AmazonServiceException&quot;&gt;
        /// Thrown when there is an error executing against QLDB.
        /// &lt;/exception&gt;
        [Obsolete(&quot;As of release 1.0, replaced by &#39;retryPolicy&#39;. Will be removed in the next major release.&quot;)]
        public T Execute&lt;T&gt;(Func&lt;TransactionExecutor, T&gt; func, Action&lt;int&gt; retryAction)
        {
            return this.Execute(func, QldbDriverBase&lt;QldbSession&gt;.DefaultRetryPolicy, retryAction);
        }

        /// &lt;summary&gt;
        /// Start a session, then execute the Executor lambda against QLDB and retrieve the result within a transaction,
        /// and end the session.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;func&quot;&gt;The Executor lambda representing the block of code to be executed within the transaction.
        /// This cannot have any side effects as it may be invoked multiple times, and the result cannot be trusted
        /// until the transaction is committed.&lt;/param&gt;
        /// &lt;param name=&quot;retryPolicy&quot;&gt;A &lt;see cref=&quot;RetryPolicy&quot;/&gt; that overrides the RetryPolicy set when creating the
        /// driver. The given retry policy will be used when retrying the transaction.&lt;/param&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The return type.&lt;/typeparam&gt;
        ///
        /// &lt;returns&gt;The return value of executing the executor. Note that if you directly return a
        /// &lt;see cref=&quot;IResult&quot;/&gt;, this will be automatically buffered in memory before the implicit commit to allow
        /// reading, as the commit will close any open results. Any other &lt;see cref=&quot;IResult&quot;/&gt; instances created within
        /// the executor block will be invalidated, including if the return value is an object which nests said
        /// &lt;see cref=&quot;IResult&quot;/&gt; instances within it.
        /// &lt;/returns&gt;
        ///
        /// &lt;exception cref=&quot;TransactionAbortedException&quot;&gt;
        /// Thrown if the Executor lambda calls &lt;see cref=&quot;TransactionExecutor.Abort&quot;/&gt;.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;QldbDriverException&quot;&gt;
        /// Thrown when called on a disposed instance.
        /// &lt;/exception&gt;
        /// &lt;exception cref=&quot;AmazonServiceException&quot;&gt;
        /// Thrown when there is an error executing against QLDB.
        /// &lt;/exception&gt;
        public T Execute&lt;T&gt;(Func&lt;TransactionExecutor, T&gt; func, RetryPolicy retryPolicy)
        {
            return this.Execute(func, retryPolicy, null);
        }

        /// &lt;summary&gt;
        /// Retrieve the table names that are available within the ledger.
        /// &lt;/summary&gt;
        ///
        /// &lt;returns&gt;The Enumerable over the table names in the ledger.&lt;/returns&gt;
        public IEnumerable&lt;string&gt; ListTableNames()
        {
            return this.Execute((txn) =&gt;
            {
                return txn.Execute(QldbDriverBase&lt;QldbSession&gt;.TableNameQuery);
            }).Select(i =&gt; i.StringValue);
        }

        internal T Execute&lt;T&gt;(Func&lt;TransactionExecutor, T&gt; func, RetryPolicy retryPolicy, Action&lt;int&gt; retryAction)
        {
            this.driverBase.ThrowIfClosed();

            bool replaceDeadSession = false;
            for (int retryAttempt = 1; true; retryAttempt++)
            {
                QldbSession session = null;
                try
                {
                    if (replaceDeadSession)
                    {
                        session = this.StartNewSession();
                    }
                    else
                    {
                        session = this.GetSession();
                    }

                    T returnedValue = session.Execute(func);
                    this.driverBase.ReleaseSession(session);
                    return returnedValue;
                }
                catch (QldbTransactionException qte)
                {
                    replaceDeadSession = this.driverBase.GetShouldReplaceDeadSessionOrThrowIfNoRetry(
                        qte,
                        session,
                        retryAttempt,
                        retryPolicy,
                        retryAction);
                }
            }
        }

        internal QldbSession GetSession()
        {
            return this.driverBase.GetSessionFromPool() ?? this.StartNewSession();
        }

        private QldbSession StartNewSession()
        {
            try
            {
                Session session = Session.StartSession(
                    this.driverBase.LedgerName,
                    this.driverBase.SessionClient,
                    this.driverBase.Logger);
                this.driverBase.Logger.LogDebug(&quot;Creating new pooled session with ID {}.&quot;, session.SessionId);
                return new QldbSession(session, this.driverBase.Logger);
            }
            catch (Exception e)
            {
                throw new RetriableException(QldbTransactionException.DefaultTransactionId, false, e);
            }
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[47,9,51,28,1],[52,9,52,10,1],[53,13,54,111,1],[55,9,55,10,1],[63,9,63,10,1],[64,13,64,44,1],[65,9,65,10,1],[71,9,71,10,1],[72,13,72,39,1],[73,9,73,10,1],[93,9,93,10,1],[94,13,94,82,1],[95,9,95,10,1],[118,9,118,10,1],[119,13,121,17,1],[121,17,121,18,1],[121,18,122,21,1],[122,21,122,40,1],[122,40,123,21,1],[123,21,123,34,1],[123,34,124,17,1],[124,17,124,18,1],[124,18,125,30,1],[126,9,126,10,1],[148,9,148,10,1],[149,13,151,17,1],[151,17,151,18,1],[151,18,152,21,1],[152,21,152,40,1],[152,40,153,21,1],[153,21,153,34,1],[153,34,154,17,1],[154,17,154,18,1],[154,18,155,30,1],[156,9,156,10,1],[184,9,184,10,1],[185,13,185,87,1],[186,9,186,10,1],[218,9,218,10,1],[219,13,219,100,1],[220,9,220,10,1],[251,9,251,10,1],[252,13,252,58,1],[253,9,253,10,1],[261,9,261,10,1],[262,13,263,13,1],[263,13,263,14,1],[263,14,264,17,1],[264,17,264,80,1],[264,80,265,13,1],[265,13,265,14,1],[265,14,265,28,1],[265,28,265,41,1],[265,41,265,43,1],[266,9,266,10,1],[269,9,269,10,1],[270,13,270,45,1],[272,13,272,45,1],[273,18,273,38,1],[273,40,273,44,1],[273,46,273,60,1],[274,13,274,14,1],[275,17,275,44,1],[277,17,277,18,1],[278,21,278,44,1],[279,21,279,22,1],[280,25,280,58,1],[281,21,281,22,1],[283,21,283,22,1],[284,25,284,53,1],[285,21,285,22,1],[287,21,287,61,1],[288,21,288,61,1],[289,21,289,42,1],[291,17,291,53,1],[292,17,292,18,1],[293,21,298,38,1],[299,17,299,18,1],[300,13,300,14,1],[301,9,301,10,1],[304,9,304,10,1],[305,13,305,83,1],[306,9,306,10,1],[309,9,309,10,1],[311,13,311,14,1],[312,17,315,45,1],[316,17,316,111,1],[317,17,317,73,1],[319,13,319,32,1],[320,13,320,14,1],[321,17,321,103,1],[323,9,323,10,1]]);
    </script>
  </body>
</html>