<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Repos\amazon-qldb-driver-dotnet\Amazon.QLDB.Driver\client\Session.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

namespace Amazon.QLDB.Driver
{
    using System.Collections.Generic;
    using System.IO;
    using System.Threading;
    using System.Threading.Tasks;
    using Amazon.IonDotnet.Builders;
    using Amazon.IonDotnet.Tree;
    using Amazon.QLDBSession;
    using Amazon.QLDBSession.Model;
    using Amazon.Runtime;
    using Microsoft.Extensions.Logging;

    /// &lt;summary&gt;
    /// Session object representing a connection with QLDB.
    /// &lt;/summary&gt;
    internal class Session
    {
        internal readonly string LedgerName;
        internal readonly IAmazonQLDBSession SessionClient;
        internal readonly string SessionId;
        private readonly string sessionToken;
        private readonly ILogger logger;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;Session&quot;/&gt; class to a specific ledger.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;ledgerName&quot;&gt;The name of the ledger to create a session to.&lt;/param&gt;
        /// &lt;param name=&quot;sessionClient&quot;&gt;The low-level session used for communication with QLDB.&lt;/param&gt;
        /// &lt;param name=&quot;sessionToken&quot;&gt;The unique identifying token for this session to QLDB.&lt;/param&gt;
        /// &lt;param name=&quot;sessionId&quot;&gt;The initial request ID for this session to QLDB.&lt;/param&gt;
        /// &lt;param name=&quot;logger&quot;&gt;The logger to inject any logging framework.&lt;/param&gt;
        internal Session(
            string ledgerName,
            IAmazonQLDBSession sessionClient,
            string sessionToken,
            string sessionId,
            ILogger logger)
        {
            this.LedgerName = ledgerName;
            this.SessionClient = sessionClient;
            this.sessionToken = sessionToken;
            this.SessionId = sessionId;
            this.logger = logger;
        }

        /// &lt;summary&gt;
        /// Async factory method for constructing a new Session, creating a new session to QLDB on construction.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;ledgerName&quot;&gt;The name of the ledger to create a session to.&lt;/param&gt;
        /// &lt;param name=&quot;sessionClient&quot;&gt;The low-level session used for communication with QLDB.&lt;/param&gt;
        /// &lt;param name=&quot;logger&quot;&gt;The logger to inject any logging framework.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;
        ///     A cancellation token that can be used by other objects or threads to receive notice of cancellation.
        /// &lt;/param&gt;
        ///
        /// &lt;returns&gt;A newly created &lt;see cref=&quot;Session&quot;/&gt;.&lt;/returns&gt;
        internal static async Task&lt;Session&gt; StartSessionAsync(
            string ledgerName,
            IAmazonQLDBSession sessionClient,
            ILogger logger,
            CancellationToken cancellationToken)
        {
            var startSessionRequest = new StartSessionRequest
            {
                LedgerName = ledgerName,
            };
            var request = new SendCommandRequest
            {
                StartSession = startSessionRequest,
            };

            logger.LogDebug(&quot;Sending start session request: {}&quot;, request);
            var response = await sessionClient.SendCommandAsync(request, cancellationToken);
            return new Session(
                ledgerName,
                sessionClient,
                response.StartSession.SessionToken,
                response.ResponseMetadata.RequestId,
                logger);
        }

        /// &lt;summary&gt;
        /// Factory method for constructing a new Session, creating a new session to QLDB on construction.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;ledgerName&quot;&gt;The name of the ledger to create a session to.&lt;/param&gt;
        /// &lt;param name=&quot;sessionClient&quot;&gt;The low-level session used for communication with QLDB.&lt;/param&gt;
        /// &lt;param name=&quot;logger&quot;&gt;The logger to inject any logging framework.&lt;/param&gt;
        ///
        /// &lt;returns&gt;A newly created &lt;see cref=&quot;Session&quot;/&gt;.&lt;/returns&gt;
        internal static Session StartSession(string ledgerName, IAmazonQLDBSession sessionClient, ILogger logger)
        {
            return
                StartSessionAsync(ledgerName, sessionClient, logger, CancellationToken.None).GetAwaiter().GetResult();
        }

        /// &lt;summary&gt;
        /// Send an asynchronous abort request to QLDB, rolling back any active changes and closing any open results.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;cancellationToken&quot;&gt;
        ///     A cancellation token that can be used by other objects or threads to receive notice of cancellation.
        /// &lt;/param&gt;
        ///
        /// &lt;returns&gt;The result of the abort transaction request.&lt;/returns&gt;
        internal virtual async Task&lt;AbortTransactionResult&gt; AbortTransactionAsync(CancellationToken cancellationToken)
        {
            var abortTransactionRequest = new AbortTransactionRequest();
            var request = new SendCommandRequest
            {
                AbortTransaction = abortTransactionRequest,
            };
            var response = await this.SendCommand(request, cancellationToken);
            return response.AbortTransaction;
        }

        /// &lt;summary&gt;
        /// Send an abort request to QLDB, rolling back any active changes and closing any open results.
        /// &lt;/summary&gt;
        ///
        /// &lt;returns&gt;The result of the abort transaction request.&lt;/returns&gt;
        internal virtual AbortTransactionResult AbortTransaction()
        {
            return this.AbortTransactionAsync(CancellationToken.None).GetAwaiter().GetResult();
        }

        /// &lt;summary&gt;
        /// Send an asynchronous end session request to QLDB and ignore exceptions.
        /// &lt;/summary&gt;
        internal virtual async void End()
        {
            try
            {
                await this.EndSessionAsync(CancellationToken.None);
            }
            catch (AmazonServiceException ase)
            {
                this.logger.LogWarning(&quot;Error disposing session: {}&quot;, ase.Message);
            }
        }

        /// &lt;summary&gt;
        /// Send an asynchronous end session request to QLDB, closing all open results and transactions.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;cancellationToken&quot;&gt;
        ///     A cancellation token that can be used by other objects or threads to receive notice of cancellation.
        /// &lt;/param&gt;
        ///
        /// &lt;returns&gt;The result of the end session request.&lt;/returns&gt;
        internal virtual async Task&lt;EndSessionResult&gt; EndSessionAsync(CancellationToken cancellationToken)
        {
            var endSessionRequest = new EndSessionRequest();
            var request = new SendCommandRequest
            {
                EndSession = endSessionRequest,
            };
            var response = await this.SendCommand(request, cancellationToken);
            return response.EndSession;
        }

        /// &lt;summary&gt;
        /// Send an end session request to QLDB, closing all open results and transactions.
        /// &lt;/summary&gt;
        ///
        /// &lt;returns&gt;The result of the end session request.&lt;/returns&gt;
        internal virtual EndSessionResult EndSession()
        {
            return this.EndSessionAsync(CancellationToken.None).GetAwaiter().GetResult();
        }

        /// &lt;summary&gt;
        /// Send an asynchronous commit request to QLDB, committing any active changes and closing any open results.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;txnId&quot;&gt;The unique ID of the transaction to commit.&lt;/param&gt;
        /// &lt;param name=&quot;commitDigest&quot;&gt;The digest hash of the transaction to commit.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;
        ///     A cancellation token that can be used by other objects or threads to receive notice of cancellation.
        /// &lt;/param&gt;
        ///
        /// &lt;returns&gt;The result of the commit transaction request.&lt;/returns&gt;
        ///
        /// &lt;exception cref=&quot;OccConflictException&quot;&gt;
        /// Thrown if an OCC conflict has been detected within the transaction.
        /// &lt;/exception&gt;
        internal virtual async Task&lt;CommitTransactionResult&gt; CommitTransactionAsync(
            string txnId,
            MemoryStream commitDigest,
            CancellationToken cancellationToken)
        {
            var commitTransactionRequest = new CommitTransactionRequest
            {
                TransactionId = txnId,
                CommitDigest = commitDigest,
            };
            var request = new SendCommandRequest
            {
                CommitTransaction = commitTransactionRequest,
            };
            var response = await this.SendCommand(request, cancellationToken);
            return response.CommitTransaction;
        }

        /// &lt;summary&gt;
        /// Send a commit request to QLDB, committing any active changes and closing any open results.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;txnId&quot;&gt;The unique ID of the transaction to commit.&lt;/param&gt;
        /// &lt;param name=&quot;commitDigest&quot;&gt;The digest hash of the transaction to commit.&lt;/param&gt;
        ///
        /// &lt;returns&gt;The result of the commit transaction request.&lt;/returns&gt;
        ///
        /// &lt;exception cref=&quot;OccConflictException&quot;&gt;
        /// Thrown if an OCC conflict has been detected within the transaction.
        /// &lt;/exception&gt;
        internal virtual CommitTransactionResult CommitTransaction(string txnId, MemoryStream commitDigest)
        {
            return this.CommitTransactionAsync(txnId, commitDigest, CancellationToken.None).GetAwaiter().GetResult();
        }

        /// &lt;summary&gt;
        /// Send an asynchronous execute request with parameters to QLDB.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;txnId&quot;&gt;The unique ID of the transaction to execute.&lt;/param&gt;
        /// &lt;param name=&quot;statement&quot;&gt;The PartiQL statement to execute.&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;The parameters to use with the PartiQL statement for execution.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;
        ///     A cancellation token that can be used by other objects or threads to receive notice of cancellation.
        /// &lt;/param&gt;
        ///
        /// &lt;returns&gt;
        /// The result of the execution, which contains a &lt;see cref=&quot;Page&quot;/&gt; representing the first data chunk.
        /// &lt;/returns&gt;
        internal virtual async Task&lt;ExecuteStatementResult&gt; ExecuteStatementAsync(
            string txnId, string statement, List&lt;IIonValue&gt; parameters, CancellationToken cancellationToken)
        {
            List&lt;ValueHolder&gt; valueHolders = null;

            try
            {
                valueHolders = parameters.ConvertAll(ionValue =&gt;
                {
                    MemoryStream stream = new MemoryStream();
                    using (var writer = IonBinaryWriterBuilder.Build(stream))
                    {
                        ionValue.WriteTo(writer);
                        writer.Finish();
                    }

                    var valueHolder = new ValueHolder
                    {
                        IonBinary = stream,
                    };
                    return valueHolder;
                });

                var executeStatementRequest = new ExecuteStatementRequest
                {
                    TransactionId = txnId,
                    Statement = statement,
                    Parameters = valueHolders,
                };
                var request = new SendCommandRequest
                {
                    ExecuteStatement = executeStatementRequest,
                };
                var response = await this.SendCommand(request, cancellationToken);
                return response.ExecuteStatement;
            }
            catch (IOException e)
            {
                throw new QldbDriverException(ExceptionMessages.FailedToSerializeParameter + e.Message, e);
            }
            finally
            {
                if (valueHolders != null)
                {
                    valueHolders.ForEach(valueHolder =&gt;
                    {
                        valueHolder.IonBinary.Dispose();
                    });
                }
            }
        }

        /// &lt;summary&gt;
        /// Send an execute request with parameters to QLDB.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;txnId&quot;&gt;The unique ID of the transaction to execute.&lt;/param&gt;
        /// &lt;param name=&quot;statement&quot;&gt;The PartiQL statement to execute.&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;The parameters to use with the PartiQL statement for execution.&lt;/param&gt;
        ///
        /// &lt;returns&gt;
        /// The result of the execution, which contains a &lt;see cref=&quot;Page&quot;/&gt; representing the first data chunk.
        /// &lt;/returns&gt;
        internal virtual ExecuteStatementResult ExecuteStatement(
            string txnId, string statement, List&lt;IIonValue&gt; parameters)
        {
            return this.ExecuteStatementAsync(txnId, statement, parameters, CancellationToken.None).GetAwaiter()
                .GetResult();
        }

        /// &lt;summary&gt;
        /// Send an asynchronous fetch result request to QLDB, retrieving the next chunk of data for the result.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;txnId&quot;&gt;The unique ID of the transaction to execute.&lt;/param&gt;
        /// &lt;param name=&quot;nextPageToken&quot;&gt;The token that indicates what the next expected page is.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;
        ///     A cancellation token that can be used by other objects or threads to receive notice of cancellation.
        /// &lt;/param&gt;
        ///
        /// &lt;returns&gt;The result of the &lt;see cref=&quot;FetchPageRequest&quot;/&gt;.&lt;/returns&gt;
        internal virtual async Task&lt;FetchPageResult&gt; FetchPageAsync(
            string txnId,
            string nextPageToken,
            CancellationToken cancellationToken)
        {
            var fetchPageRequest = new FetchPageRequest
            {
                TransactionId = txnId,
                NextPageToken = nextPageToken,
            };
            var request = new SendCommandRequest
            {
                FetchPage = fetchPageRequest,
            };
            var response = await this.SendCommand(request, cancellationToken);
            return response.FetchPage;
        }

        /// &lt;summary&gt;
        /// Send a fetch result request to QLDB, retrieving the next chunk of data for the result.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;txnId&quot;&gt;The unique ID of the transaction to execute.&lt;/param&gt;
        /// &lt;param name=&quot;nextPageToken&quot;&gt;The token that indicates what the next expected page is.&lt;/param&gt;
        ///
        /// &lt;returns&gt;The result of the &lt;see cref=&quot;FetchPageRequest&quot;/&gt;.&lt;/returns&gt;
        internal virtual FetchPageResult FetchPage(string txnId, string nextPageToken)
        {
            return this.FetchPageAsync(txnId, nextPageToken, CancellationToken.None).GetAwaiter().GetResult();
        }

        /// &lt;summary&gt;
        /// Send an asynchronous start transaction request to QLDB.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;cancellationToken&quot;&gt;
        ///     A cancellation token that can be used by other objects or threads to receive notice of cancellation.
        /// &lt;/param&gt;
        ///
        /// &lt;returns&gt;The result of the start transaction request.&lt;/returns&gt;
        internal virtual async Task&lt;StartTransactionResult&gt; StartTransactionAsync(
            CancellationToken cancellationToken)
        {
            var startTransactionRequest = new StartTransactionRequest();
            var request = new SendCommandRequest
            {
                StartTransaction = startTransactionRequest,
            };
            var response = await this.SendCommand(request, cancellationToken);
            return response.StartTransaction;
        }

        /// &lt;summary&gt;
        /// Send a start transaction request to QLDB.
        /// &lt;/summary&gt;
        ///
        /// &lt;returns&gt;The result of the start transaction request.&lt;/returns&gt;
        internal virtual StartTransactionResult StartTransaction()
        {
            return this.StartTransactionAsync(CancellationToken.None).GetAwaiter().GetResult();
        }

        /// &lt;summary&gt;
        /// Send an asynchronous request to QLDB.
        /// &lt;/summary&gt;
        ///
        /// &lt;param name=&quot;request&quot;&gt;The request to send.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;
        ///     A cancellation token that can be used by other objects or threads to receive notice of cancellation.
        /// &lt;/param&gt;
        ///
        /// &lt;returns&gt;The result returned by QLDB for the request.&lt;/returns&gt;
        private async Task&lt;SendCommandResponse&gt; SendCommand(
            SendCommandRequest request, CancellationToken cancellationToken)
        {
            request.SessionToken = this.sessionToken;
            this.logger.LogDebug(&quot;Sending request: {}&quot;, request);
            return await this.SessionClient.SendCommandAsync(request, cancellationToken);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[47,9,52,28,1],[53,9,53,10,1],[54,13,54,42,1],[55,13,55,48,1],[56,13,56,46,1],[57,13,57,40,1],[58,13,58,34,1],[59,9,59,10,1],[78,9,78,10,1],[79,13,82,15,1],[83,13,86,15,1],[88,13,88,75,1],[89,13,89,93,1],[90,13,95,25,1],[96,9,96,10,1],[108,9,108,10,1],[109,13,110,119,1],[111,9,111,10,1],[123,9,123,10,1],[124,13,124,73,1],[125,13,128,15,1],[129,13,129,79,1],[130,13,130,46,1],[131,9,131,10,1],[139,9,139,10,1],[140,13,140,96,1],[141,9,141,10,1],[147,9,147,10,1],[149,13,149,14,1],[150,17,150,68,1],[151,13,151,14,0],[152,13,152,47,1],[153,13,153,14,1],[154,17,154,84,1],[155,13,155,14,1],[156,9,156,10,1],[168,9,168,10,1],[169,13,169,61,1],[170,13,173,15,1],[174,13,174,79,1],[175,13,175,40,1],[176,9,176,10,1],[184,9,184,10,1],[185,13,185,90,1],[186,9,186,10,1],[207,9,207,10,1],[208,13,212,15,1],[213,13,216,15,1],[217,13,217,79,1],[218,13,218,47,1],[219,9,219,10,1],[234,9,234,10,1],[235,13,235,118,1],[236,9,236,10,1],[254,9,254,10,1],[255,13,255,51,1],[258,13,258,14,1],[259,17,260,17,1],[260,17,260,18,1],[260,18,261,21,1],[261,21,261,62,1],[261,62,262,28,1],[262,28,262,77,1],[262,77,263,21,1],[263,21,263,22,1],[263,22,264,25,1],[264,25,264,50,1],[264,50,265,25,1],[265,25,265,41,1],[265,41,266,21,1],[266,21,266,22,1],[266,22,268,21,1],[268,21,271,23,1],[271,23,272,21,1],[272,21,272,40,1],[272,40,273,17,1],[273,17,273,18,1],[273,18,273,20,1],[275,17,280,19,1],[281,17,284,19,1],[285,17,285,83,1],[286,17,286,50,1],[288,13,288,34,0],[289,13,289,14,0],[290,17,290,108,0],[293,13,293,14,1],[294,17,294,42,1],[295,17,295,18,1],[296,21,297,21,1],[297,21,297,22,1],[297,22,298,25,1],[298,25,298,57,1],[298,57,299,21,1],[299,21,299,22,1],[299,22,299,24,1],[300,17,300,18,1],[301,13,301,14,1],[302,9,302,10,1],[317,9,317,10,1],[318,13,319,30,1],[320,9,320,10,1],[337,9,337,10,1],[338,13,342,15,1],[343,13,346,15,1],[347,13,347,79,1],[348,13,348,39,1],[349,9,349,10,1],[360,9,360,10,1],[361,13,361,111,1],[362,9,362,10,1],[375,9,375,10,1],[376,13,376,73,1],[377,13,380,15,1],[381,13,381,79,1],[382,13,382,46,1],[383,9,383,10,1],[391,9,391,10,1],[392,13,392,96,1],[393,9,393,10,1],[407,9,407,10,1],[408,13,408,54,1],[409,13,409,66,1],[410,13,410,90,1],[411,9,411,10,1]]);
    </script>
  </body>
</html>